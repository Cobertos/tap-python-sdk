## TapStrap Python SDK (beta)

### What Is This ?

TAP python SDK allows you to build python app that can establish BLE connection with the Tap Strap, send commands and receive  events and data - Thus allowing TAP to act as a controller for your app!
The library is developed with Python > 3.6 and is currently on beta. Please fel free to contact with any issue/comment. 


### Supported Platforms
This package supports the following platforms:
* MacOS (tested on 10.15.2) - using Apple's CoreBluetooth library. The library depends on PyObjC which Apple includes with their Python version on OSX. Note that if you're using a different Python, be sure to install PyObjC for that version of Python.  
* Windows 10 - by including the dynamic library (DLL) generated by tap-standalonewin-sdk:
    1. Clone [tap-standalonewin-sdk](https://github.com/TapWithUs/tap-standalonewin-sdk).
    2. Build the project using Visual Studio
    3. Extract TapWinSDK.DLL from ....

### Installation  
Clone this repo and install the package.
```console
git clone https://github.com/TapWithUs/tap-python-sdk
cd tap-python-sdk
python setup.py install
```
> For Windows, make sure you place TapWinSDK.dll at XXXXXXX 

Then just import the main class
```python
from tapsdk import TapSDK
tap_device = TapSDK()
```

### Features

This SDK implements two basic interfaces with the Tap Strap.
First is setting the operation mode of the Tap strap:

1. **Text mode** - the strap will operate normally, with no events being sent to the SDK
2. **Controller mode** - the strap will send events to the SDK
3. **Raw data mode** - the strap will send raw sensors data to the SDK

Second, subscribing to the following Tap events:

1. **Tap event** - whenever a tap event has occured
2. **Mouse event** - whenever a mouse movement has occured
3. **AirGesture event** - for 3D gestures
4. **Raw data** - stream of raw data. This mode also allows specific configuration commands that will be described later.

The SDK uses callbacks to implement user functions on the various events. To register a callback, you have to instance a TapSDK object and just:

```python
    def on_tap_event(self, identifier, tapcode):
        print(identifier + " tapped " + str(tapcode))

    tap_device.register_tap_events(on_tap_event)
```
#### Commands list
1. ```set_input_mode(self, mode):```
This function send a mode selection command. It allows any of the following modes:
* Text mode
* Controller mode
* Raw sensors mode

2. ```set_haptic_command(self, haptics):```
This function send a series of haptic activations. ```haptics``` is a list of integers indicates for the actiation and delay periods one after another. The periods are in millisecond units , in the range of [10,2550] and in resolution of 10ms. Each haptic command support up to 18 period definitions (i.e. 9 haptics + delay pairs).  
For example, 
    ```python 
        haptics=[1000,300,200]
    ```  
    will trigger a 1s haptic, followed by 300ms delay, followed by 200ms haptic.


#### Events list
1. centralBluetoothState(poweredOn:Bool)

Called whenever bluetooth state is changed. You can use this function to alert the user for example.


2. tapConnected(withIdentifier identifier: String, name: String)

Called when a TAP device is connected to the iOS device, sending the TAP identifier and it's display name.
Each TAP device has an identifier (a unique string) to allow you to keep track of all the taps that are connected
(if for example you're developing a multiplayer game, you need to keep track of the players).
This identifier is used in the rest of the TAPKitDelegate functions.
* TAPKit does NOT scan for TAP devices, therefor the use must pair the devices to the iOS device first.


3. tapDisconnected(withIdentifier identifier: String)

Called when a TAP device is disconnected from the iOS device, sending the TAP identifier.



4. tapFailedToConnect(withIdentifier identifier: String, name: String)

Called when a TAP device failed to connect, sending the TAP identifier and it's display name.
```python
sdfsdf
```

5. ```OnTapped(self, identifier, tapcode)```

This function will tell you which TAP was being tapped (identifier), and which fingers are tapped (tapcode). ```tapcode``` is a 8-bit unsigned number, between 1 and 31 which is formed by a binary  representation of the fingers that are tapped.
The LSb is thumb finger, the MSb is the pinky finger. 
For example: if combination equls 5 - it's binary form is 10100 - means that the thumb and the middle fingers were tapped.

6. ```OnMoused(self, identifier, vx, vy, isMouse)```

This function will be called when the user is using the TAP as a mouse.
```vx``` and ```vx``` are the horizontal and vertical velocities of the mouse movement respectively.
```isMouse``` is a boolean that indicates for proximity with a surface.

7. ```OnRawSensors(self, identifier, data)```
This function will be clled whenever a new raw sensors data packet is being received.

    In raw sensors mode, the TAP continuously sends raw data from the following sensors:
    1. Five 3-axis accelerometers on each finger ring.
        * sampled at 200Hz
        * allows dinamic range configuration (2G,4G,8G,16G)
    2. IMU (3-axis accelerometer + gyro) located on the thumb (**for TAP Strap 2 only**).
        * sampled at 208Hz. 
        * allows dinamic range configuration for the accelerometer (±2G, ±4G, ±8G, ±16G) and for the gyro (±125dps, ±250dps, ±500dps, +-1000dps).

The sensors measurements are given with respect to the reference system below.
![alt text](TAP-axis-alpha.png "Tap Strap reference frame")

The



## Get the connected TAPS

If you wish at any point in your app, as long as TAPKit has been started, you can receive a dictionary of connected taps.

```swift
    let taps = TAPKit.sharedKit.getConnectedTaps()
```
While the result is a dictionary where the key is the tap identifier, and the value is it's display name.


## TAPInputMode

Each TAP has a mode in which it works as.
Two modes available:
CONTROLLER MODE (Default) - allows receiving the "tapped" func callback in TAPKitDelegate with the fingers combination without any post-processing.
TEXT MODE - the TAP device will behave as a plain bluetooth keyboard, "tapped" func in TAPKitDelegate will not be called.

When a TAP device is connected it is by default set to controller mode.

If you wish for a TAP to act as a bluetooth keyboard and allow the user to enter text input in your app, you can set the mode:

```swift
    TAPKit.sharedKit.setTAPInputMode(TAPInputMode.text, forIdentifiers: [String])
```

The first parameter is the mode. You can use any of these modes: TAPInputMode.controller, TAPInputMode.text
the second parameter is an array of identifiers of TAP devices that you want to change the mode. You can pass nil if you want ALL the TAP devices to change their mode.

Just don't forget to switch back to controller mode after the user has entered the text :

```swift
TAPKit.sharedKit.setTAPInputMode(TAPInputMode.controller, forIdentifiers: [String])
```

You can ask TAPKit which mode a specific TAP device is in.
The result is a string, which can be compared to TAPInputMode.text or TAPInputMode.controller :

```swift
    let mode = TAPKit.sharedKit.getTAPInputMode(forTapIdentifier: identifier)
    if mode == TAPInputMode.controller {

    } else if mode == TAPInputMode.text {

    }
```

### Examples

Take a look at the examples folder.

### Support

Please refer to the issues tab! :)



